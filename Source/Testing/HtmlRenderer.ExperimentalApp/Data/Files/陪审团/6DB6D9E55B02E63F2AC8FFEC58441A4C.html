
<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ACM  POJ 1015 Jury Compromise（陪审团的人选，动态规划题，难） - kuangbin - 博客园</title>
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=m_FXmwz3wxZoecUwNEK23PAzc-j9vbX_C6MblJ5ouMc1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/BOOK/bundle-BOOK.css?v=fWz3cvIoU0CG8iD-sCmV803XvYIy-SbgoBMZsoVHw9M1"/>
<link id="mobile-style" media="only screen and (max-width: 768px)" type="text/css" rel="stylesheet" href="/skins/BOOK/bundle-BOOK-mobile.css?v=LUvqpSqTyRS1PkUPHXQz7MLe7xXzjopFakWpGxQsAkw1"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/kuangbin/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/kuangbin/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/kuangbin/wlwmanifest.xml"/>
<script src="//common.cnblogs.com/script/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">var currentBlogApp = 'kuangbin', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="/bundles/blog-common.js?v=E1-LyrzANB2jbN9omtnpOHx3eU0Kt3DyislfhU0b5p81" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>
<div id="page_begin_html"></div><script>load_page_begin_html();</script>

<script type="text/javascript">
	try {
		if (screen.availWidth > 1200) {
			document.getElementById("MainCss").href = '/Skins/BOOK/style2.css';
		}
	} catch (e) { }
</script>

<div id="header">
<div id="HeaderTitle">
<div id="Title">
<a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/kuangbin/">ACM博客_kuangbin 新博客kuangbin.org</a>
</div>
<div id="subTitle">人一我百，人十我万！追逐青春的梦想，怀着自信的心，永不放弃！ by kuangbin 新博客 kuangbin.org</div>
</div>
</div>

<div id="main">
	
<div id="post_detail">
	<div class="post">
		<h2>
			<a id="cb_post_title_url" href="http://www.cnblogs.com/kuangbin/archive/2011/08/04/2126809.html">ACM  POJ 1015 Jury Compromise（陪审团的人选，动态规划题，难）</a>
		</h2>
		<div id="cnblogs_post_body"><div class="ptt" lang="en-US">Jury Compromise</div>
<div class="plm">
<table align="center">
<tbody>
<tr>
<td><strong>Time Limit:</strong> 1000MS</td>
<td width="10">&nbsp;</td>
<td colspan="3"><strong>Memory Limit:</strong> 65536K</td>
</tr>
<tr>
<td><strong>Total Submissions:</strong> 18378</td>
<td width="10">&nbsp;</td>
<td><strong>Accepted:</strong> 4516</td>
<td width="10">&nbsp;</td>
<td style="color: red; font-weight: bold;">Special Judge</td>
</tr>
</tbody>
</table>
</div>
<p class="pst">Description</p>
<div class="ptx" lang="en-US">In Frobnia, a far-away country, the verdicts in court trials are determined by a jury consisting of members of the general public. Every time a trial is set to begin, a jury has to be selected, which is done as follows. First, several people are drawn randomly from the public. For each person in this pool, defence and prosecution assign a grade from 0 to 20 indicating their preference for this person. 0 means total dislike, 20 on the other hand means that this person is considered ideally suited for the jury. <br />Based on the grades of the two parties, the judge selects the jury. In order to ensure a fair trial, the tendencies of the jury to favour either defence or prosecution should be as balanced as possible. The jury therefore has to be chosen in a way that is satisfactory to both parties. <br />We will now make this more precise: given a pool of n potential jurors and two values di (the defence's value) and pi (the prosecution's value) for each potential juror i, you are to select a jury of m persons. If J is a subset of {1,..., n} with m elements, then D(J ) = sum(dk) k belong to J <br />and P(J) = sum(pk) k belong to J are the total values of this jury for defence and prosecution. <br />For an optimal jury J , the value |D(J) - P(J)| must be minimal. If there are several jurys with minimal |D(J) - P(J)|, one which maximizes D(J) + P(J) should be selected since the jury should be as ideal as possible for both parties. <br />You are to write a program that implements this jury selection process and chooses an optimal jury given a set of candidates.</div>
<p class="pst">Input</p>
<div class="ptx" lang="en-US">The input file contains several jury selection rounds. Each round starts with a line containing two integers n and m. n is the number of candidates and m the number of jury members. <br />These values will satisfy 1&lt;=n&lt;=200, 1&lt;=m&lt;=20 and of course m&lt;=n. The following n lines contain the two integers pi and di for i = 1,...,n. A blank line separates each round from the next. <br />The file ends with a round that has n = m = 0.</div>
<p class="pst">Output</p>
<div class="ptx" lang="en-US">For each round output a line containing the number of the jury selection round ('Jury #1', 'Jury #2', etc.). <br />On the next line print the values D(J ) and P (J ) of your jury as shown below and on another line print the numbers of the m chosen candidates in ascending order. Output a blank before each individual candidate number. <br />Output an empty line after each test case.</div>
<p class="pst">Sample Input</p>
<pre class="sio">4 2 
1 2 
2 3 
4 1 
6 2 
0 0 </pre>
<p class="pst">Sample Output</p>
<pre class="sio">Jury #1 
Best jury has value 6 for prosecution and value 4 for defence: 
 2 3 </pre>
<p class="pst">Hint</p>
<div class="ptx" lang="en-US">If your solution is based on an inefficient algorithm, it may not execute in the allotted time.</div>
<p class="pst">Source</p>
<div class="ptx" lang="en-US"><a href="http://poj.org/searchproblem?field=source&amp;key=Southwestern+European+Regional+Contest+1996">Southwestern European Regional Contest 1996</a></div>
<div class="ptx" lang="en-US">&nbsp;</div>
<div class="ptx" lang="en-US">&nbsp;</div>
<div class="ptx" lang="en-US">中文：</div>
<div class="ptx" lang="en-US"><dl class="problem-content"><dt>描述</dt><dd>在遥远的国家佛罗布尼亚，嫌犯是否有罪，须由陪审团决定。陪审团是由法官从公众中挑选的。先随机挑选n个人作为陪审团的候选人，然后再从这n个人中选m人组成陪审团。选m人的办法是：<br /><br />控方和辩方会根据对候选人的喜欢程度，给所有候选人打分，分值从0到20。为了公平起见，法官选出陪审团的原则是：选出的m个人，必须满足辩方总分和控方总分的差的绝对值最小。如果有多种选择方案的辩方总分和控方总分的之差的绝对值相同，那么选辩控双方总分之和最大的方案即可。</dd><dt>输入</dt><dd>输入包含多组数据。每组数据的第一行是两个整数n和m，n是候选人数目，m是陪审团人数。注意，1&lt;=n&lt;=200, 1&lt;=m&lt;=20 而且 m&lt;=n。接下来的n行，每行表示一个候选人的信息，它包含2个整数，先后是控方和辩方对该候选人的打分。候选人按出现的先后从1开始编号。两组有效数据之间以空行分隔。最后一组数据n=m=0</dd><dt>输出</dt><dd>对每组数据，先输出一行，表示答案所属的组号,如 'Jury #1', 'Jury #2', 等。接下来的一行要象例子那样输出陪审团的控方总分和辩方总分。再下来一行要以升序输出陪审团里每个成员的编号，两个成员编号之间用空格分隔。每组输出数据须以一个空行结束。</dd><dt>样例输入</dt><dd>
<pre>4 2 
1 2 
2 3 
4 1 
6 2 
0 0 </pre>
</dd><dt>样例输出</dt><dd>
<pre>Jury #1 
Best jury has value 6 for prosecution and value 4 for defence: 
 2 3 </pre>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;"><br />在遥远的国家佛罗布尼亚，嫌犯是否有罪，须由陪审团决定。陪审团是<br />由法官从公众中挑选的。先随机挑选n 个人作为陪审团的候选人，然后<br />再从这n 个人中选m 人组成陪审团。选m 人的办法是：控方和辩方会<br />根据对候选人的喜欢程度，给所有候选人打分，分值从0 到20。为了<br />公平起见，法官选出陪审团的原则是：选出的m 个人，必须满足辩方<br />总分和控方总分的差的绝对值最小。如果有多种选择方案的辩方总分<br />和控方总分的之差的绝对值相同，那么选辩控双方总分之和最大的<br />方案即可。最终选出的方案称为陪审团方案。<br />    为叙述问题方便，现将任一选择方案中，辩方总分和控方总分<br />之差简称为&ldquo;辩控差&rdquo;，辩方总分和控方总分之和称为&ldquo;辩控和&rdquo;。<br />第i 个候选人的辩方总分和控方总分之差记为V(i)，辩方总分和控<br />方总分之和记为S(i)。现用f(j, k)表示，取j 个候选人，使其辩<br />控差为k 的所有方案中，辩控和最大的那个方案（该方案称为&ldquo;方<br />案f(j, k)&rdquo;）的辩控和。并且，我们还规定，如果没法选j 个人，<br />使其辩控差为k，那么f(j, k)的值就为-1，也称方案f(j, k)不可行。<br />本题是要求选出m 个人，那么，如果对k 的所有可能的取值，求<br />出了所有的f(m, k) (-20&times;m&le; k &le; 20&times;m)，那么陪审团方案<br />自然就很容易找到了。<br />    问题的关键是建立递推关系。需要从哪些已知条件出发，<br />才能求出f(j, k)呢？显然，方案f(j, k)是由某个可行的方案f(j-1, x)<br />( -20&times;m &le; x &le; 20&times;m)演化而来的。可行方案f(j-1, x)能演化成<br />方案f(j, k)的必要条件是：存在某个候选人i，i 在方案f(j-1, x)中<br />没有被选上，且x+V(i) = k。在所有满足该必要条件的f(j-1, x)中，<br />选出 f(j-1, x) + S(i) 的值最大的那个，那么方案f(j-1, x)再加上候选人i，<br />就演变成了方案 f(j, k)。这中间需要将一个方案都选了哪些人都记录下来。<br />不妨将方案f(j, k)中最后选的那个候选人的编号，记在二维数组的<br />元素path[j][k]中。那么方案f(j, k)的倒数第二个人选的编号，<br />就是path[j-1][k-V[path[j][k]]。假定最后算出了解方案的辩控差是k，<br />那么从path[m][k]出发，就能顺藤摸瓜一步步求出所有被选中的候选人。<br />初始条件，只能确定f(0, 0) = 0。由此出发，一步步自底向上递推，<br />就能求出所有的可行方案f(m, k)( -20&times;m &le; k &le; 20&times;m)。实际解题<br />的时候，会用一个二维数组f 来存放f(j, k)的值。而且，由于题目中辩<br />控差的值k 可以为负数，而程序中数租下标不能为负数，所以，在程序中<br />不妨将辩控差的值都加上400，以免下标为负数导致出错，即题目描述中，<br />如果辩控差为0，则在程序中辩控差为400。<br /><br /><br /></span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />#include</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">stdio.h</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br />#include</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">stdlib.h</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br />#include</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">iostream</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br />#include</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">string</span><span style="color: #000000;">.h</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br /></span><span style="color: #0000ff;">using</span><span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;<br /></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> f[</span><span style="color: #800080;">30</span><span style="color: #000000;">][</span><span style="color: #800080;">1000</span><span style="color: #000000;">];<br /></span><span style="color: #008000;">//</span><span style="color: #008000;">f[j,k]表示：取j个候选人，使其辩控差为k的方案中<br /></span><span style="color: #008000;">//</span><span style="color: #008000;">辩控和最大的那个方案（该方案称为&ldquo;方案f(j,k)&rdquo;)的控辩和</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> Path[</span><span style="color: #800080;">30</span><span style="color: #000000;">][</span><span style="color: #800080;">1000</span><span style="color: #000000;">];<br /></span><span style="color: #008000;">//</span><span style="color: #008000;">Path数组用来记录选了哪些人<br /></span><span style="color: #008000;">//</span><span style="color: #008000;">方案f(j,k)中最后选的那个候选人的编号，记在Path[j][k]中</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> P[</span><span style="color: #800080;">300</span><span style="color: #000000;">];</span><span style="color: #008000;">//</span><span style="color: #008000;">控方打分 </span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> D[</span><span style="color: #800080;">300</span><span style="color: #000000;">]; </span><span style="color: #008000;">//</span><span style="color: #008000;">辩方打分</span><span style="color: #008000;"><br /></span><span style="color: #000000;"><br /></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> Answer[</span><span style="color: #800080;">30</span><span style="color: #000000;">];</span><span style="color: #008000;">//</span><span style="color: #008000;">存放最终方案的人选</span><span style="color: #008000;"><br /></span><span style="color: #000000;"><br /></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cmp(</span><span style="color: #0000ff;">const</span><span style="color: #0000ff;">void</span><span style="color: #000000;">*</span><span style="color: #000000;">a,</span><span style="color: #0000ff;">const</span><span style="color: #0000ff;">void</span><span style="color: #000000;">*</span><span style="color: #000000;">b)<br />{<br />    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">*</span><span style="color: #000000;">(</span><span style="color: #0000ff;">int</span><span style="color: #000000;">*</span><span style="color: #000000;">)a</span><span style="color: #000000;">-*</span><span style="color: #000000;">(</span><span style="color: #0000ff;">int</span><span style="color: #000000;">*</span><span style="color: #000000;">)b;<br />}     <br /></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br />{<br />   </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,j,k;<br />    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> t1,t2;<br />    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,m;<br />    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> nMinP_D;</span><span style="color: #008000;">//</span><span style="color: #008000;">辩控双方总分一样时的辩控差</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> iCase;</span><span style="color: #008000;">//</span><span style="color: #008000;">测试数据编号</span><span style="color: #008000;"><br /></span><span style="color: #000000;">    iCase</span><span style="color: #000000;">=</span><span style="color: #800080;">0</span><span style="color: #000000;">;<br />    </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span><span style="color: #000000;">,</span><span style="color: #000000;">&amp;</span><span style="color: #000000;">n,</span><span style="color: #000000;">&amp;</span><span style="color: #000000;">m))<br />    {<br />        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(n</span><span style="color: #000000;">==</span><span style="color: #800080;">0</span><span style="color: #000000;">&amp;&amp;</span><span style="color: #000000;">m</span><span style="color: #000000;">==</span><span style="color: #800080;">0</span><span style="color: #000000;">)</span><span style="color: #0000ff;">break</span><span style="color: #000000;">;<br />        iCase</span><span style="color: #000000;">++</span><span style="color: #000000;">;<br />        </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(i</span><span style="color: #000000;">=</span><span style="color: #800080;">1</span><span style="color: #000000;">;i</span><span style="color: #000000;">&lt;=</span><span style="color: #000000;">n;i</span><span style="color: #000000;">++</span><span style="color: #000000;">)<br />           scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d %d</span><span style="color: #800000;">"</span><span style="color: #000000;">,</span><span style="color: #000000;">&amp;</span><span style="color: #000000;">P[i],</span><span style="color: #000000;">&amp;</span><span style="color: #000000;">D[i]);<br />        memset(f,</span><span style="color: #000000;">-</span><span style="color: #800080;">1</span><span style="color: #000000;">,</span><span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(f));<br />        memset(Path,</span><span style="color: #800080;">0</span><span style="color: #000000;">,</span><span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(Path));<br />        nMinP_D</span><span style="color: #000000;">=</span><span style="color: #000000;">m</span><span style="color: #000000;">*</span><span style="color: #800080;">20</span><span style="color: #000000;">;</span><span style="color: #008000;">//</span><span style="color: #008000;">题目中的辩控差为0，对应于程序中的辩控差为m*20</span><span style="color: #008000;"><br /></span><span style="color: #000000;">        f[</span><span style="color: #800080;">0</span><span style="color: #000000;">][nMinP_D]</span><span style="color: #000000;">=</span><span style="color: #800080;">0</span><span style="color: #000000;">;<br />         </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(j</span><span style="color: #000000;">=</span><span style="color: #800080;">0</span><span style="color: #000000;">;j</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">m;j</span><span style="color: #000000;">++</span><span style="color: #000000;">)</span><span style="color: #008000;">//</span><span style="color: #008000;">每次循环选出第j个人，共要选出m人 </span><span style="color: #008000;"><br /></span><span style="color: #000000;">        {<br />            </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(k</span><span style="color: #000000;">=</span><span style="color: #800080;">0</span><span style="color: #000000;">;k</span><span style="color: #000000;">&lt;=</span><span style="color: #000000;">nMinP_D</span><span style="color: #000000;">*</span><span style="color: #800080;">2</span><span style="color: #000000;">;k</span><span style="color: #000000;">++</span><span style="color: #000000;">)</span><span style="color: #008000;">//</span><span style="color: #008000;